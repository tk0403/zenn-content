---
title: "TiDBとMySQLの違い（外部キー制約とロック確認の仕方）"
emoji: "⛳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["tidb","DBaaS"]
published: false # 公開設定（falseにすると下書き）
---

# はじめに
MySQLと互換性を持ったNewSQLデータベース・・・TiDBということで、日本ではMySQLユーザーが多い（？）と噂されていることもあり、
気になっている方はいらっしゃるんじゃないかと思います。

ただ、100%互換ではない、ということでなかなか重い腰が上がらないかたもいらっしゃるのは事実じゃないでしょうか？

今回はMySQLとの互換性という観点で、TiDBにおける外部キー制約について確認していきたいと思います。

これまでの経緯からご紹介しておくと、TiDBは当初外部キーのサポートがされていませんでした。
しかし、v6.6より外部キー制約がサポートされました。
:::message
ただし、現在はまだExperimental Feature扱いとなっています。
:::

TiDBユーザーからは「外部キーがサポートされたーー！！」という喜びの声を聞く一方で、いざ使ってみたらパフォーマンスで影響を受けたケースがあったので、その点について特に紹介していきます。

結論から言うと、
TiDBで外部キーを使う場合、`LOCK IN SHARE MODE`が未サポートのため、以下のようなパフォーマンス上の制約をうけることがあるのでその点について紹介してきます。

TiDBのDocsにおいても[外部キーに関する制約事項](https://docs.pingcap.com/tidb/stable/foreign-key#locking)として触れられている内容となります。
:::message
Because TiDB currently does not support `LOCK IN SHARE MODE``, if a child table accepts a large number of concurrent writes and most of the referenced foreign key values are the same, there might be serious locking conflicts.
:::

それではこの内容を具体的に見ていきましょう。

# 実機で確認：MySQLとTiDBの挙動の違い
## 前提（環境）
ローカル環境で試してみます。
```
# MySQL
% mysql --version
mysql  Ver 8.0.32 for macos13.0 on arm64 (Homebrew)
```

TiDB（TiUP Playground）
※執筆時点でちょうどTiDB 7.5(LTS)がGAとなりましたのでそちらを使います。  
tiup playgroundの使い方についてはこちら  
https://zenn.dev/shigeyuki/articles/8663e1598ecfa5
```
# TiDB
% tiup playground v7.5.0  
tiup is checking updates for component playground ...
Starting component `playground`: /Users/tkusaka/.tiup/components/playground/v1.14.0/tiup-playground v7.5.0
Start pd instance:v7.5.0
Start tikv instance:v7.5.0
Start tidb instance:v7.5.0
Waiting for tidb instances ready
127.0.0.1:4000 ... Done
Start tiflash instance:v7.5.0
Waiting for tiflash instances ready
127.0.0.1:3930 ... Done

🎉 TiDB Playground Cluster is started, enjoy!

Connect TiDB:    mysql --comments --host 127.0.0.1 --port 4000 -u root
TiDB Dashboard:  http://127.0.0.1:2379/dashboard
Grafana:         http://127.0.0.1:3000
```
また、MySQL、TiDB双方ともに分離レベルはデフォルトのRepeatable Readで確認します。
※TiDBではRepeatable Readの他にRead Commitedがサポートされています
```sql
# MySQL
mysql> SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;
+--------------------------------+-------------------------+
| @@GLOBAL.transaction_isolation | @@transaction_isolation |
+--------------------------------+-------------------------+
| REPEATABLE-READ                | REPEATABLE-READ         |
+--------------------------------+-------------------------+
1 row in set (0.00 sec)

```
```sql
# TiDB
mysql> SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;
+--------------------------------+-------------------------+
| @@GLOBAL.transaction_isolation | @@transaction_isolation |
+--------------------------------+-------------------------+
| REPEATABLE-READ                | REPEATABLE-READ         |
+--------------------------------+-------------------------+
1 row in set (0.01 sec)
```
## 事前準備
MySQL、TiDBそれぞれに以下のようなテーブルを作成します。
```sql
mysql> create table parent (id bigint not null primary key auto_increment, name varchar(64) not null);
Query OK, 0 rows affected (0.09 sec)

mysql> create table child (id bigint not null primary key auto_increment, pid bigint not null,  name varchar(64) not null, INDEX idx_pid (pid),FOREIGN KEY (pid) REFERENCES parent(id) ON DELETE CASCADE);
Query OK, 0 rows affected (0.15 sec)

mysql> DESC parent;
+-------+-------------+------+------+---------+----------------+
| Field | Type        | Null | Key  | Default | Extra          |
+-------+-------------+------+------+---------+----------------+
| id    | bigint(20)  | NO   | PRI  | NULL    | auto_increment |
| name  | varchar(64) | NO   |      | NULL    |                |
+-------+-------------+------+------+---------+----------------+
2 rows in set (0.00 sec)

mysql> DESC child;
+-------+-------------+------+------+---------+----------------+
| Field | Type        | Null | Key  | Default | Extra          |
+-------+-------------+------+------+---------+----------------+
| id    | bigint(20)  | NO   | PRI  | NULL    | auto_increment |
| pid   | bigint(20)  | NO   | MUL  | NULL    |                |
| name  | varchar(64) | NO   |      | NULL    |                |
+-------+-------------+------+------+---------+----------------+
3 rows in set (0.00 sec)
```
続いて、MySQL、TiDB双方の親テーブル`parant`に以下のレコードを登録しておきます。
```sql
INSERT INTO parent (name) VALUES ("山田 親郎");
```

## 動作確認
MySQLとTiDB双方で親テーブルのレコードと親子関係にあるレコードを子テーブルにInsertしていきます。
そのときの親テーブルの親レコードでのロックの取り方に違いがあります。

では早速見ていきましょう。 
### MySQLの場合
まずは子テーブルへデータを挿入します。※COMMITはまだしません
```sql
# Transaction 1：子テーブルへの挿入
BEGIN；
INSERT INTO parent (name) VALUES ("山田 子一");
# COMMITはまだしません
```
つづいて、親テーブルのレコードのロック状態を確認します。
```sql
# Transaction 2：親テーブルのレコードのロック状態を確認
SELECT * FROM sys.innodb_lock_waits\G
# 結果を貼る
```
ここで分かる通り、MySQLでは排他ロックではなく照会可能なロックモードで親のレコードのロックを獲得しています。
実際に他のトランザクションから親のレコードを参照することが可能です。
```sql
# Transaction 3：親テーブルのレコードを確認
SELECT * FROM parent;
# 結果を貼る
```
### TiDBの場合
続いて、同じことをTiDBでも試してみます。
まずは子テーブルへデータを挿入します。※COMMITはまだしません
```sql
# Transaction 1：子テーブルへの挿入
BEGIN；
INSERT INTO parent (name) VALUES ("山田 子一");
# COMMITはまだしません
```
つづいて、親テーブルのレコードのロック状態を確認します。
ここで、ロックの状態確認は少しMySQLと異なるのですが、、、、、細かいことはあとで説明するとして、いったん以下のようにロック状態を確認します。
```sql
# Transaction 2：親テーブルのレコードのロック状態を確認
SELECT * FROM sys.innodb_lock_waits\G
# 結果を貼る
```

## つまりどういうケースで困る（ボトルネックになる？）
上で示した例のように、特定の親テーブルのレコードと関連のある子テーブルのレコードをINSERT、UPDATE、DELETEを大量に実行するケースは、親のレコードのロック待ちとなり、パフォーマンス上のボトルネックになり得ることがあります。
理由は前述したとおり、`LOCK IN SHARE MODE`が未サポートのため、親レコードの参照待ちとなるから、ということになります。

このケースを念頭に踏まえた上で、TiDBでは外部キー制約を利用することになります。
※そのため、Docs上も冒頭に性能面の検証を十分に確認してから外部キー制約の利用をおすすめする旨が記載されています

ただ、検討した結果、外部キー制約そのものは利用したい（DB移行のため利用せざるを得ない）場合、以下を検討することをおすすめします。
* `foreign_key_checks`を無効化する（デフォルトは有効化されています）
https://docs.pingcap.com/tidb/stable/system-variables#foreign_key_checks

このパラメータをOFFにした場合、いわゆる外部キーチェックをスキップして処理することにより、ボトルネックは解消されます。
シレッと言いましたが、外部キー制約チェックがスキップされるため、外部キーそのものの意義が失われると考えてください。
ただ、例えば親テーブルのレコードが更新されるケースは実質的にほとんどなく、そもそも親子関係が損なわれるようなことが起こらない場合はご利用頂いていいかもしれません。

スキップされる動作についての詳細は以下の項をご参照ください。
https://docs.pingcap.com/tidb/stable/foreign-key#foreign-key-constraint-check


## TiDBでロックの状態を確認する方法
以下の資料でも言及されています。（PingCAPによるウェビナー資料）
https://speakerdeck.com/pingcap0315/tidbdenorotukujing-he-notoraburusiyuteingu?slide=29

以下のSQLでそれぞれ確認が可能です

・ロック保持側の接続情報
```sql
SELECT trx.session_id AS holding_session_id, trx.id AS holding_transaction_id FROM information_schema.data_lock_waits AS l LEFT JOIN information_schema.cluster_tidb_trx AS trx ON l.CURRENT_HOLDING_TRX_ID = trx.id;
```
・待っている側（ロック解放待ち）の接続情報
```sql
SELECT trx.session_id AS waiting_session_id, trx.id AS waiting_transaction_id FROM information_schema.data_lock_waits AS l LEFT JOIN information_schema.cluster_tidb_trx AS trx ON l.trx_id = trx.id;
```

上記SQLの元ネタとなるテーブルの詳細情報はこのあたりが参考になります。


１．[DATA_LOCK_WAITS](https://docs.pingcap.com/tidb/stable/information-schema-data-lock-waits)
```sql
SELECT * FROM data_lock_waits\G
```
２．[CLUSTER_TIDB_TRX](https://docs.pingcap.com/tidb/stable/information-schema-tidb-trx#cluster_tidb_trx)
```sql
SELECT * FROM cluster_tidb_trx where db = <database_name>\G
```
３．[CLUSTER_PROCESSLIST](https://docs.pingcap.com/tidb/stable/information-schema-processlist#cluster_processlist)
```sql
SELECT * FROM cluster_processlist where db = <database_name>\G
```
